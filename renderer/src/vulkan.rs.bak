use std::{
    error::Error,
    ffi,
    os::raw::c_char,
};

use ash::{
    vk, 
    ext::debug_utils,
    Device,
    khr::{
        swapchain, 
        surface,
    },
};
use winit::raw_window_handle::{HasDisplayHandle, HasWindowHandle};

use crate::window;

pub struct Vulkan {
    entry: ash::Entry,
    instance: ash::Instance,
    device: ash::Device,
    physical_device: vk::PhysicalDevice,
}

mod dispatchable;

impl Vulkan {
    fn create_instance(
        entry: &ash::Entry, window: &window::Window,
    ) -> Result<ash::Instance, Box<dyn Error>> {
        let to_ret: ash::Instance;
        //TODO(shrink unsafe blocks)
        unsafe {
            //TODO(config)
            let app_name = ffi::CStr::from_bytes_with_nul_unchecked(b"Test Renderer\0");

            let appinfo = vk::ApplicationInfo::default()
                .application_name(&app_name)
                .application_version(0)
                .engine_name(app_name)
                .engine_version(0)
                .api_version(vk::make_api_version(0, 1, 0, 0));

            //TODO(config, layer names)
            let layer_names = [ffi::CStr::from_bytes_with_nul_unchecked(
                b"VK_LAYER_KHRONOS_validation\0",
            )];

            let layers_names_raw: Vec<*const c_char> = layer_names
                .iter()
                .map(|raw_name| raw_name.as_ptr())
                .collect();

            let mut extension_names =
                ash_window::enumerate_required_extensions(
                    window.window.display_handle()?.as_raw()
                ).unwrap().to_vec();

            extension_names.push(debug_utils::NAME.as_ptr());

            let create_flags = if cfg!(any(target_os = "macos", target_os = "ios")) {
                vk::InstanceCreateFlags::ENUMERATE_PORTABILITY_KHR
            } else {
                vk::InstanceCreateFlags::default()
            };

            let create_info = vk::InstanceCreateInfo::default()
                .application_info(&appinfo)
                .enabled_layer_names(&layers_names_raw)
                .enabled_extension_names(&extension_names)
                .flags(create_flags);

            //TODO(error)
            to_ret = entry
                .create_instance(&create_info, None)
                .expect("Instance creation error");
        }
        Ok(to_ret)
    }

    fn create_device(
        entry: &ash::Entry, instance: &ash::Instance, window: &crate::Window,
    ) -> Result<Device, Box<dyn Error>> {
        let to_ret: Device;
        unsafe {
            let device_extension_names_raw = [
                swapchain::NAME.as_ptr(),
                #[cfg(any(target_os = "macos", target_os = "ios"))]
                ash::khr::portability_subset::NAME.as_ptr(),
            ];

            let surface = ash_window::create_surface(
                &entry,
                &instance,
                window.window.display_handle()?.as_raw(),
                window.window.window_handle()?.as_raw(),
                None,
            )?;

            let surface_loader = surface::Instance::new(&entry, &instance);

            let pdevices = instance
                .enumerate_physical_devices()
                .expect("Physical device error");

            let (pdevice, queue_family_index) = pdevices
                .iter()
                .find_map(|pdevice| {
                    instance
                        .get_physical_device_queue_family_properties(*pdevice)
                        .iter()
                        .enumerate()
                        .find_map(|(index, info)| {
                            let supports_graphic_and_surface =
                                info.queue_flags.contains(vk::QueueFlags::GRAPHICS)
                                    && surface_loader
                                        .get_physical_device_surface_support(
                                            *pdevice,
                                            index as u32,
                                            surface,
                                        )
                                        .unwrap();
                            if supports_graphic_and_surface {
                                Some((*pdevice, index))
                            } else {
                                None
                            }
                        })
                })
                .expect("Couldn't find suitable device.");

            let features = vk::PhysicalDeviceFeatures {
                shader_clip_distance: 1,
                ..Default::default()
            };

            let priorities = [1.0];

            let queue_family_index = queue_family_index as u32;

            let queue_info = vk::DeviceQueueCreateInfo::default()
                .queue_family_index(queue_family_index)
                .queue_priorities(&priorities);

            let device_create_info = vk::DeviceCreateInfo::default()
                .queue_create_infos(std::slice::from_ref(&queue_info))
                .enabled_extension_names(&device_extension_names_raw)
                .enabled_features(&features);

            to_ret = instance
                .create_device(pdevice, &device_create_info, None)
                .unwrap();
        }
        Ok(to_ret)
    }

    fn create_physical_device() {

    }

    pub fn new(window: &window::Window) -> Result<Self, Box<dyn Error>> {
        let entry = ash::Entry::linked();
        let instance = Vulkan::create_instance(&entry, window)?;
        let device = Vulkan::create_device(&entry, &instance, window);
        let physical_device = Vulkan::create_physical_device();
        todo!("building it");
    }
}
